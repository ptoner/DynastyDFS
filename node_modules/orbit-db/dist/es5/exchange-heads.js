'use strict';

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Channel = require('ipfs-pubsub-1on1');

var Logger = require('logplease');
var logger = Logger.create("exchange-heads", { color: Logger.Colors.Yellow });
Logger.setLogLevel('ERROR');

var getHeadsForDatabase = function getHeadsForDatabase(store) {
  return store && store._oplog ? store._oplog.heads : [];
};

var exchangeHeads = async function exchangeHeads(ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated) {
  var _handleMessage = function _handleMessage(message) {
    var msg = JSON.parse(message.data);
    var address = msg.address,
        heads = msg.heads;

    onMessage(address, heads);
  };

  var channel = getDirectConnection(peer);
  if (!channel) {
    try {
      logger.debug('Create a channel to ' + peer);
      channel = await Channel.open(ipfs, peer);
      channel.on('message', _handleMessage);
      logger.debug('Channel created to ' + peer);
      onChannelCreated(channel);
    } catch (e) {
      logger.error(e);
    }
  }

  // Wait for the direct channel to be fully connected
  await channel.connect();
  logger.debug('Connected to ' + peer

  // Send the heads if we have any
  );var heads = getHeadsForDatabase(getStore(address));
  logger.debug('Send latest heads of \'' + address + '\':\n', (0, _stringify2.default)(heads.map(function (e) {
    return e.hash;
  }), null, 2));
  if (heads) {
    channel.send((0, _stringify2.default)({ address: address, heads: heads }));
  }

  return channel;
};

module.exports = exchangeHeads;